<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/05/test/" class="article-date">
  <time class="dt-published" datetime="2023-09-04T17:11:07.000Z" itemprop="datePublished">2023-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/05/test/">test</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/test/" data-id="clm552pep0001xsivgk1ig222" data-title="test" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hooks" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/26/hooks/" class="article-date">
  <time class="dt-published" datetime="2023-06-25T16:24:56.000Z" itemprop="datePublished">2023-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/26/hooks/">hooks</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>title: React Hooks</p>
<hr>
<p>目錄：<br>[TOC]</p>
<p> 摘要<br>本報告有稍微探討React Hooks的底層原理，並編寫程式碼實現例子。首先概述React Hooks的背景和目的，然後稍微討論其底層實現原理。接著，介紹一些React Hooks，並通過一個實例演示來展示其用法。最後，總結本報告的內容並提出一些結論。</p>
<h1 id="理論篇"><a href="#理論篇" class="headerlink" title="理論篇"></a>理論篇</h1><h2 id="React的理念"><a href="#React的理念" class="headerlink" title="React的理念"></a><code>React</code>的理念</h2><blockquote>
<p>我們認為，React 是用 JavaScript 構建快速響應的大型 Web 應用程序的首選方式。它在 Facebook 和 Instagram 上表現優秀。</p>
</blockquote>
<ul>
<li>瓶頸</li>
</ul>
<p>為滿足60Hz以上的刷新率，瀏覽器必須小於<code>16.6ms</code>就刷新一次</p>
<p>而我們又知道GUI渲染線程與JS線程式互斥的，所以<code>JS腳本執行</code>和<code>瀏覽器布局、繪製</code>不能同時執行</p>
<p>所以當JS腳本執行時間過長時，超過16.6ms，在這一幀瀏覽器就沒有刷新頁面，導致顯示掉幀，造成卡頓</p>
<p>以下段程式碼為例，我們將會在瀏覽器渲染3000個<code>li</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="number">3000</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;Array(len).fill(0).map((_, i) =&gt; <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;i&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#root&quot;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, rootEl);  </span><br></pre></td></tr></table></figure>
<p>但是從執行堆棧圖看到，JS執行時間為73.65ms，遠遠多於1幀的時間。<br><img src="https://hackmd.io/_uploads/rJko-J8Oh.png"></p>
<p>為了解決這個問題<code>React</code>使用了<code>時間切片</code>(time slice)的操作，將較長的任務切分到每一幀執行，這使得必須將同步的更新改為可中斷的異步更新。</p>
<p>React為實現快速響應，在v15升級到v16後重構了整個架構</p>
<h2 id="老的React架構"><a href="#老的React架構" class="headerlink" title="老的React架構"></a>老的React架構</h2><p>分兩層：</p>
<ul>
<li>Reconciler（協調器）—— 負責找出變化的組件 </li>
<li>Renderer（渲染器）—— 負責將變化的組件渲染到頁面上</li>
</ul>
<h3 id="Reconciler（協調器）"><a href="#Reconciler（協調器）" class="headerlink" title="Reconciler（協調器）"></a>Reconciler（協調器）</h3><p><a target="_blank" rel="noopener" href="https://legacy.reactjs.org/docs/codebase-overview.html#reconcilers">官方解釋</a></p>
<p>當調用<code>this.setState</code>、<code>this.forceUpdate</code>或<code>ReactDOM.remder</code>等其他觸發更新的API時，Reconciler（協調器）就會工作。</p>
<ol>
<li>調用函數組件、或class組件的render方法，將返回的JSX轉化為虛擬DOM</li>
<li>將虛擬DOM和上次更新時的虛擬DOM對比</li>
<li>通過對比找出本次更新中變化的虛擬DOM</li>
<li>通知Renderer將變化的虛擬DOM渲染到頁面上</li>
</ol>
<h3 id="Renderer（渲染器）"><a href="#Renderer（渲染器）" class="headerlink" title="Renderer（渲染器）"></a>Renderer（渲染器）</h3><p><a target="_blank" rel="noopener" href="https://legacy.reactjs.org/docs/codebase-overview.html#renderers">官方解釋</a><br><code>React</code>在不同平台有不同的Renderer。</p>
<ul>
<li>ReactDOM渲染器，渲染到瀏覽器DOM</li>
<li>ReactNative渲染器，渲染App原生組件</li>
<li>ReactTest渲染器，渲染用於測試的純JS對象</li>
<li>ReactArt渲染器，渲染到Canvas、SVG</li>
</ul>
<h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><p>在<code>Reconciler</code>中，<code>mount</code>的組件會調用<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498"><code>mountComponent</code></a>，<code>update</code>的組件會調用<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877"><code>updateComponent</code></a>。這兩個方法都會遞迴更新子組件。<br>於是形成 call stack 的結構，而遞迴的過程是不能中斷且是同步的，如果當遞迴層數過深，一旦時間超過16ms，瀏覽器刷新就會卡頓。</p>
<h2 id="新的Recat架構"><a href="#新的Recat架構" class="headerlink" title="新的Recat架構"></a>新的Recat架構</h2><p>分三層：</p>
<ul>
<li>Scheduler（調度器）—— 調度任務的優先級，高優任務優先進入Reconciler </li>
<li>Reconciler（協調器）—— 負責找出變化的組件 </li>
<li>Renderer（渲染器）—— 負責將變化的組件渲染到頁面上</li>
</ul>
<h3 id="Scheduler（調度器）"><a href="#Scheduler（調度器）" class="headerlink" title="Scheduler（調度器）"></a>Scheduler（調度器）</h3><p>為了執行程式不超過16.6ms，需要一種機制，讓瀏覽器通知是否有剩餘時間，做為要不要中斷程式的標準。</p>
<p>由於<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-TW/docs/Web/API/Window/requestIdleCallback">requestIdleCallback</a>具有瀏覽器兼容性以及不穩定的觸發頻率，因此<code>React</code>並沒有採用，而是使用功能更完整的<code>requestIdleCallback-polyfill</code> AKA Scheduler。</p>
<h3 id="Fiber-Reconciler（協調器）"><a href="#Fiber-Reconciler（協調器）" class="headerlink" title="Fiber Reconciler（協調器）"></a>Fiber Reconciler（協調器）</h3><p>在React16中，更新從遞迴變成了可中斷的迴圈。在每次循環都會調用<code>shouldYield</code>判斷當前是否有剩餘時間</p>
<p>由於依靠遞迴的VirtualDOM資料無法改為非同步且可中斷的更新，於是誕生了一樣是虛擬的樹狀結構的fiber tree。在fiber架構下，是使用linked list資料結構來遍歷component tree。</p>
<p>在React Fiber架構下，linked list traversal演算法在每一個node之間都只會各有一個child（子節點）、sibling（兄弟節點）、return（父節點）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Heading 1&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;Heading 2&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;Heading 3&lt;/h3&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>以上結構為例，在fiber架構下只會把第一個 <code>&lt;h1&gt;</code> 當作 child，其他則使用 child 的 sibling 來記錄，並且透過 return 指回 parent node。<br>遍歷fiber tree是以while迴圈實現而非遞迴，遍歷規則如下</p>
<ul>
<li>DFS</li>
<li>child -&gt; 自身 &gt; sibling<br>舉例：<br><img src="https://hackmd.io/_uploads/BJ8s8AHO3.gif"></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673">referenlink</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@noinline</span> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Hooks-是啥"><a href="#Hooks-是啥" class="headerlink" title="Hooks 是啥?"></a>Hooks 是啥?</h2><blockquote>
<p>Hook 是React 16.8 中增加的新功能。它讓你不必寫class 就能使用state 以及其他React 的功能。</p>
</blockquote>
<p>Hook是另一種複用狀態邏輯的解決方案，React開發者一直以來對狀態邏輯的複用方案不斷提出以及改進，從Mixin到高階組件到Render Propss 到現在的Hook。</p>
<h3 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h3><p><img src="https://hackmd.io/_uploads/B1e3uCH_n.png"><br>Mixin繼承可以被看作是一種通過擴展來收集功能的方式。每個新對象都有一個原型，可以從中繼承更多屬性。原型可以繼承自其他對象，更重要的是可以為任意數量的對象定義屬性。利用這一事實，我們可以促進功能的重用。</p>
<p>在React中，Mixin主要用於在完全不相關的兩個組件之間具有一套基本相似的功能時，可以將其提取出來並通過Mixin注入的方式實現程式碼復用。例如，不同的組件需要每隔一段時間更新一次，我們可以通過創建setInterval()函數來實現這個功能，並在組件銷毀時卸載此函數。因此，可以創建一個簡單的Mixin，提供一個簡單的setInterval()函數，在組件被銷毀時自動清理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">SetIntervalMixin</span> = &#123;</span><br><span class="line">  <span class="attr">componentWillMount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intervals</span> = [];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">setInterval</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intervals</span>.<span class="title function_">push</span>(<span class="built_in">setInterval</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">componentWillUnmount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intervals</span>.<span class="title function_">forEach</span>(<span class="built_in">clearInterval</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createReactClass = <span class="built_in">require</span>(<span class="string">&#x27;create-React-class&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">TickTock</span> = <span class="title function_">createReactClass</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [<span class="title class_">SetIntervalMixin</span>], <span class="comment">// 使用 mixin</span></span><br><span class="line">  <span class="attr">getInitialState</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">seconds</span>: <span class="number">0</span>&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">componentDidMount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="built_in">setInterval</span>(<span class="variable language_">this</span>.<span class="property">tick</span>, <span class="number">1000</span>); <span class="comment">// 調用 mixin 上的方法</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">tick</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">seconds</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">seconds</span> + <span class="number">1</span>&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">render</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        React has been running for &#123;this.state.seconds&#125; seconds.</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">TickTock</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="缺點-1"><a href="#缺點-1" class="headerlink" title="缺點"></a>缺點</h3><ol>
<li>不同mixin可能會相互依賴，耦合性太強，導致後期維護成本過高</li>
<li>mixin中的命名可能會衝突，無法使用同一命名的mixin</li>
<li>mixin即使開始很簡單，它們會隨著業務場景增多，時間的推移產生滾雪球式的複雜化<br><img src="https://hackmd.io/_uploads/H1fVcArd3.png"></li>
</ol>
<h3 id="HOC（高階組件）"><a href="#HOC（高階組件）" class="headerlink" title="HOC（高階組件）"></a>HOC（高階組件）</h3><blockquote>
<p>A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React’s compositional nature.</p>
</blockquote>
<blockquote>
<p>Concretely, a higher-order component is a function that takes a component and returns a new component.</p>
</blockquote>
<p>舉例：通過高階組件動態給其他組件增加日誌打印功能，而不影響原先組件的功能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Next props: &#x27;</span>, nextProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h3><blockquote>
<p>The term “render prop” refers to a technique for sharing code between React components using a prop whose value is a function.</p>
</blockquote>
<blockquote>
<p>A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic.</p>
</blockquote>
<p>以下我們提供了一個帶有prop的組件，它能夠動態決定什麼需要渲染，這樣就能對組件的邏輯以及狀態復用，而不用改變它的渲染結構。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> mouse = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">mouse</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/cat.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">position:</span> &#x27;<span class="attr">absolute</span>&#x27;, <span class="attr">left:</span> <span class="attr">mouse.x</span>, <span class="attr">top:</span> <span class="attr">mouse.y</span> &#125;&#125; /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleMouseMove</span> = <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleMouseMove</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">x</span>: event.<span class="property">clientX</span>,</span><br><span class="line">      <span class="attr">y</span>: event.<span class="property">clientY</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> &#x27;<span class="attr">100</span>%&#x27; &#125;&#125; <span class="attr">onMouseMove</span>=<span class="string">&#123;this.handleMouseMove&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.render(this.state)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseTracker</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>移動鼠標!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;mouse</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        )&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而通常我們說的Render Props 是因為模式才被稱為 Render Props ，又不是因為一定要用render對prop進行命名。我們也可以這樣來表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Mouse</span>&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">mouse</span> =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Cat</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;</span> /&gt;</span></span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/<span class="title class_">Mouse</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="引入Hooks的動機"><a href="#引入Hooks的動機" class="headerlink" title="引入Hooks的動機"></a>引入Hooks的動機</h3><p>引入React Hooks的主要動機是為了解決以下問題：</p>
<ol>
<li>複雜的組件結構<br>在React中，當組件邏輯變得複雜時，我們可能會使用高階組件（Higher-Order Components）或渲染屬性（Render Props）等模式來共享邏輯。這種方式可能導致組件層級的深度嵌套，使程式碼難以理解和維護。</li>
</ol>
<p>Hooks提供了一種更直接的方式來共享和重用組件邏輯，減少了層級嵌套。</p>
<ol start="2">
<li>難以理解的生命週期方法<br>類組件中的生命週期方法（如componentDidMount和componentDidUpdate）往往需要在不同的生命週期階段編寫相關程式碼。這使得邏輯分散，難以追踪。</li>
</ol>
<p>Hooks通過提供單個useEffect Hook來處理組件的副作用和生命週期，使得邏輯更加集中和易於理解。</p>
<ol start="3">
<li>難以重用的狀態邏輯<br>在類組件中，要在多個組件之間共享狀態邏輯，通常需要使用高階組件或渲染屬性。這樣的模式增加了額外的複雜性，使得狀態邏輯的複用變得困難。</li>
</ol>
<p>Hooks通過提供useState和其他自定義Hooks，使得狀態邏輯的重用更加簡單和直接。</p>
<p>這些問題和挑戰促使React團隊設計並引入了React Hooks，以改進狀態管理和副作用處理的方式。</p>
<h1 id="實作篇"><a href="#實作篇" class="headerlink" title="實作篇"></a>實作篇</h1><h2 id="useState-Hook"><a href="#useState-Hook" class="headerlink" title="useState Hook"></a>useState Hook</h2><p>useState是React Hooks中最常用的一個。它允許我們在函數組件中使用和管理局部狀態（state）。通過useState，我們可以定義一個狀態變量，並在需要時更新它。<br>以下是useState的基本語法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initialState);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>state</code>：狀態變量，用於存儲和訪問狀態的值。</li>
<li><code>setState</code>：用於更新狀態變量的函數。當調用setState時，React會重新渲染組件，並將新的狀態值應用到相應的地方。</li>
<li><code>initialState</code>：狀態的初始值。</li>
</ul>
<p>例如，我們可以使用useState來管理一個計數器的狀態：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count - 1)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程式碼中，我們使用useState定義了一個名為count的狀態變量，並通過setCount函數來更新它。每次點擊”Increment”或”Decrement”按鈕時，計數器的值會相應地增加或減少。</p>
<h2 id="useEffect-Hook"><a href="#useEffect-Hook" class="headerlink" title="useEffect Hook"></a>useEffect Hook</h2><p>useEffect是另一個常用的React Hook，用於處理副作用和生命週期。副作用包括數據獲取、訂閱、手動DOM操作等。在函數組件中，我們可以使用useEffect來處理這些副作用。<br>以下是useEffect的基本語法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 副作用程式碼</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清理程式碼</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [dependency]);</span><br></pre></td></tr></table></figure>
<ul>
<li>副作用程式碼：在useEffect的函數參數中定義副作用的邏輯。這段程式碼將在組件渲染後執行。</li>
<li>清理程式碼（可選）：如果需要在組件卸載時執行一些清理操作，可以在返回的函數中定義清理程式碼。</li>
<li>依賴數組（可選）：一個數組，包含影響副作用執行的依賴項。只有當依賴項發生變化時，副作用程式碼才會重新執行。</li>
</ul>
<p>例如，我們可以使用useEffect來獲取和顯示數據：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DataDisplay</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在組件渲染後，獲取數據並更新狀態</span></span><br><span class="line">    <span class="title function_">fetchData</span>()</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> <span class="title function_">setData</span>(response))</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在組件卸載時清理操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cleanup</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []); <span class="comment">// 空的依賴數組，表示副作用只在組件首次渲染後執行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data ? (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Data: &#123;data&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ) : (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程式碼中，我們使用useEffect來獲取數據並更新狀態。當組件首次渲染後，副作用程式碼會執行，然後將獲取的數據設置為狀態的值。在組件卸載時，清理程式碼會執行清理操作。</p>
<h2 id="useContext-Hook"><a href="#useContext-Hook" class="headerlink" title="useContext Hook"></a>useContext Hook</h2><p>useContext Hook用於在React組件之間共享上下文（context）。上下文是一種跨組件層級傳遞數據的方式，它可以幫助我們避免通過多層嵌套的props傳遞數據。<br>以下是useContext的基本語法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>MyContext：上下文對象，通過React.createContext創建。</li>
</ul>
<p>例如，我們可以創建一個主題上下文，並在組件中使用它來動態設置主題樣式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 創建上下文</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ThemeProvider</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ThemeProvider</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用上下文</span></span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;theme</span> === <span class="string">&#x27;dark&#x27;</span> ? &#x27;<span class="attr">dark-theme</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">light-theme</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 組件內容 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程式碼中，我們通過React.createContext創建了一個主題上下文（ThemeContext）。然後，在App組件中通過ThemeProvider組件將上下文提供給子組件。在ThemeProvider組件中，我們使用useContext來獲取當前的主題，從而動態設置組件的樣式。</p>
<h2 id="useReducer-Hook"><a href="#useReducer-Hook" class="headerlink" title="useReducer Hook"></a>useReducer Hook</h2><p>useReducer Hook是一個類似於Redux中的reducer的狀態管理工具。它適用於管理複雜的狀態邏輯，當狀態具有多個相關值時特別有用。<br>以下是useReducer的基本語法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br></pre></td></tr></table></figure>
<ul>
<li>state：狀態變量，用於存儲和訪問狀態的值。</li>
<li>dispatch：派發函數，用於觸發狀態變更的操作。</li>
<li>reducer：一個函數，根據舊的狀態和操作類型返回新的狀態。reducer函數接收兩個參數：舊的狀態和操作對象。</li>
<li>initialState：狀態的初始值。</li>
</ul>
<p>例如，我們可以使用useReducer來管理一個簡單的計數器狀態：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatch] = <span class="title function_">useReducer</span>(reducer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程式碼中，我們定義了一個reducer函數來處理不同的操作類型（INCREMENT和DECREMENT），並返回新的狀態。通過useReducer，我們將reducer函數和初始值0傳遞給它，並獲取到當前的計數器狀態以及派發函數。每次點擊”Increment”或”Decrement”按鈕時，我們通過dispatch函數觸發對應的操作，從而更新計數器的狀態</p>
<h2 id="useCallback和useMemo-Hooks"><a href="#useCallback和useMemo-Hooks" class="headerlink" title="useCallback和useMemo Hooks"></a>useCallback和useMemo Hooks</h2><p>useCallback和useMemo是用於性能優化的Hooks。它們都可以用於避免不必要的重新計算。 </p>
<ul>
<li>useCallback用於緩存函數引用，避免在每次渲染時創建新的函數實例。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 函數體</span></span><br><span class="line">&#125;, [dependency]);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>useMemo用於緩存計算結果，只有當依賴項發生變化時才重新計算。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 計算結果</span></span><br><span class="line">&#125;, [dependency]);</span><br></pre></td></tr></table></figure>
在性能敏感的場景下，使用useCallback和useMemo可以有效減少不必要的計算和渲染。</li>
</ul>
<h2 id="useRef-Hook"><a href="#useRef-Hook" class="headerlink" title="useRef Hook"></a>useRef Hook</h2><p>useRef Hook用於獲取DOM節點的引用或保存其他可變值。它類似於類組件中的ref屬性。 </p>
<p>以下是useRef的基本語法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = <span class="title function_">useRef</span>(initialValue);</span><br></pre></td></tr></table></figure>
<ul>
<li>ref：引用對象，可以在組件的整個生命週期中保持穩定。</li>
<li>initialValue：初始值。</li>
<li>例如，我們可以使用useRef來獲取輸入框的引用並設置焦點：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TextInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Focus<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程式碼中，我們使用useRef創建了一個inputRef引用對象，並將它綁定到輸入框的ref屬性上。當點擊”Focus”按鈕時，我們調用inputRef.current.focus()來設置輸入框的焦點。</p>
<h2 id="React-Hooks的最佳用法"><a href="#React-Hooks的最佳用法" class="headerlink" title="React Hooks的最佳用法"></a>React Hooks的最佳用法</h2><ol>
<li>遵循Hooks規則<br>React Hooks有一些特定的規則需要遵循，以確保其正確使用。</li>
</ol>
<ul>
<li>Hooks只能在函數組件的頂層使用，不要在循環、條件語句或嵌套函數中使用。</li>
<li>Hooks的調用順序必須保持一致，不要在條件語句中改變調用順序。</li>
<li>Hooks的命名必須以”use”開頭，這有助於標識其為Hooks。<br>遵循這些規則可以確保Hooks的正確性和一致性。</li>
</ul>
<ol start="2">
<li>將邏輯拆分為獨立的Hooks<br>為了提高程式碼的可讀性和可維護性，建議將組件的狀態管理邏輯和副作用邏輯拆分為獨立的自定義Hooks。</li>
</ol>
<p>將邏輯封裝為獨立的Hooks可以使組件更加簡潔和可複用。這樣，當組件的需求變化時，只需要調整對應的Hooks，而不需要修改組件本身的程式碼。</p>
<ol start="3">
<li>注意依賴項的設置<br>在使用useEffect、useCallback和useMemo等Hooks時，需要注意正確設置依賴項。</li>
</ol>
<p>依賴項是一個數組，用於指定在依賴項變化時觸發Hooks的重新執行。如果依賴項沒有正確設置，可能會導致意外的行為和性能問題。</p>
<p>確保依賴項準確反映需要跟踪的數據，避免不必要的重新計算和渲染。</p>
<ol start="4">
<li>使用React DevTools進行調試<br>React DevTools是一個強大的調試工具，可以幫助我們理解組件的狀態和渲染行為。</li>
</ol>
<p>在使用React Hooks時，建議使用React DevTools來檢查組件的狀態、props和Hooks的執行順序。這有助於調試和優化組件的性能。</p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>本報告探討了React Hooks的底層原理，並提供了一些相關的背景知識。首先，介紹了React的理念和React v16之前的架構，解釋了由於同步更新的限制而導致應用程序卡頓的問題。接著，介紹了React v16之後的架構，包括Scheduler、Fiber Reconciler和Renderer，並詳細解釋了Fiber架構下的更新機制。最後，引入了React Hooks作為解決狀態邏輯複用的解決方案，並比較了Mixin、HOC和Render Props等其他解決方案的缺點。</p>
<p>結論：</p>
<ol>
<li>React v16的架構重構解決了同步更新造成的應用程序卡頓問題，並提供了可中斷的異步更新機制。</li>
<li>React Hooks提供了一種更簡單、更直觀的方式來實現狀態邏輯的複用，避免了Mixin、HOC和Render Props等解決方案的一些缺點。</li>
<li>使用React Hooks可以使程式碼更加簡潔、易於理解和維護，並提高開發效率。</li>
<li>開發者應該適時地使用React Hooks來提高程式碼的可讀性和可重用性，並根據具體的業務場景選擇最適合的解決方案。</li>
</ol>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a target="_blank" rel="noopener" href="https://reactjs.org/">React官方</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/81323354">听说你还不懂React Hook？ - 知乎专栏</a><br><a target="_blank" rel="noopener" href="https://medium.com/starbugs/react-%E9%96%8B%E7%99%BC%E8%80%85%E4%B8%80%E5%AE%9A%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%BA%95%E5%B1%A4%E6%9E%B6%E6%A7%8B-react-fiber-c3ccd3b047a1">React 開發者一定要知道的底層機制— React Fiber Reconciler</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/26/hooks/" data-id="clm552peh0000xsivashf373y" data-title="hooks" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/05/test/">test</a>
          </li>
        
          <li>
            <a href="/2023/06/26/hooks/">hooks</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>